{"id": "ef1f80fe-d3a8-43db-8530-e42cf461502f", "code": "\"\"\"\nBaseline model for bean yield prediction\n\nReads ./data/train.csv and ./data/test.csv\nwrites predictions to ./result/submission.csv with columns [year, month, state, yield].\n\nThe EVOLVE-BLOCK marks the scope that OpenEvolve is allowed to tune.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\n# construct real path from judge.py's ROOT\ndef construct_real_path(root):\n    PROJECT_ROOT = Path(root)\n    INPUT_DIR = PROJECT_ROOT\n    OUTPUT_DIR = PROJECT_ROOT.parent / \"outputs\" / \"submission\"\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    TRAIN_PATH = INPUT_DIR / \"train.csv\"\n    TEST_PATH = INPUT_DIR / \"test.csv\"\n\n    return TRAIN_PATH, TEST_PATH, OUTPUT_DIR\n\n# EVOLVE-BLOCK-START\nfrom typing import Dict, Tuple, List\nimport numpy as np\nimport lightgbm as lgb\nimport pandas as pd\n\n\ndef encode_state(df: pd.DataFrame, mapping: Dict[str, int] | None = None) -> Tuple[pd.DataFrame, Dict[str, int]]:\n    df = df.copy()\n    if mapping is None:\n        states = sorted(df[\"state\"].astype(str).unique())\n        mapping = {s: i for i, s in enumerate(states)}\n    df[\"state_enc\"] = df[\"state\"].astype(str).map(mapping).fillna(-1).astype(int)\n    return df, mapping\n\n\ndef months_since_crop_start(df: pd.DataFrame) -> pd.DataFrame:\n    df = df.copy()\n\n    def transform(m: int) -> int:\n        return m - 10 if m >= 10 else m + 2\n\n    df[\"months_since_crop_start\"] = df[\"month\"].astype(int).apply(transform)\n    return df\n\n\ndef add_time_features(df: pd.DataFrame) -> pd.DataFrame:\n    df = df.copy()\n    m = df[\"month\"].astype(float)\n    df[\"month_sin\"] = np.sin(2.0 * np.pi * m / 12.0)\n    df[\"month_cos\"] = np.cos(2.0 * np.pi * m / 12.0)\n    df[\"month_sq\"] = m * m\n    # simple interactions that often help tree models\n    df[\"state_x_month\"] = df[\"state_enc\"].astype(float) * m\n    df[\"state_x_phase\"] = df[\"state_enc\"].astype(float) * df[\"months_since_crop_start\"].astype(float)\n    return df\n\n\ndef _target_encode(\n    train: pd.DataFrame,\n    test: pd.DataFrame,\n    cols: List[str],\n    target: str = \"yield\",\n    alpha: float = 20.0,\n) -> Tuple[pd.Series, pd.Series]:\n    \"\"\"Smoothed target encoding computed on full train; mapped onto train/test.\"\"\"\n    global_mean = float(train[target].mean())\n    agg = train.groupby(cols, dropna=False)[target].agg([\"mean\", \"count\"]).reset_index()\n    agg[\"te\"] = (agg[\"mean\"] * agg[\"count\"] + global_mean * alpha) / (agg[\"count\"] + alpha)\n    key = cols\n    tr = train[key].merge(agg[key + [\"te\"]], on=key, how=\"left\")[\"te\"].fillna(global_mean)\n    te = test[key].merge(agg[key + [\"te\"]], on=key, how=\"left\")[\"te\"].fillna(global_mean)\n    return tr, te\n\n\ndef train_and_predict(root) -> Path:\n    # do not change this line\n    train_path, test_path, output_path = construct_real_path(root)\n\n    train = pd.read_csv(train_path)\n    test = pd.read_csv(test_path)\n\n    # base transforms\n    train, state2idx = encode_state(train)\n    test, _ = encode_state(test, mapping=state2idx)\n    train = months_since_crop_start(train)\n    test = months_since_crop_start(test)\n    train = add_time_features(train)\n    test = add_time_features(test)\n\n    # smoothed target encodings (strong for region + season)\n    for cols in ([\"state_enc\"], [\"month\"], [\"year\"], [\"state_enc\", \"month\"], [\"state_enc\", \"months_since_crop_start\"]):\n        tr_te, te_te = _target_encode(train, test, cols=cols, target=\"yield\", alpha=30.0)\n        name = \"te_\" + \"_\".join(cols)\n        train[name] = tr_te.astype(float)\n        test[name] = te_te.astype(float)\n\n    # feature selection (numeric only; keep engineered TE/time features)\n    numeric_kinds = (\"b\", \"i\", \"u\", \"f\", \"c\")\n    candidate_features = [c for c in train.columns if c != \"yield\"]\n    features = [c for c in candidate_features if train[c].dtype.kind in numeric_kinds]\n\n    X = train[features].copy()\n    X_test = test[features].copy()\n\n    # robust missing handling\n    med = X.median(numeric_only=True)\n    X = X.fillna(med)\n    X_test = X_test.fillna(med)\n\n    # log-transform helps RMSE+MAPE tradeoff; clip at 0 on inverse\n    y = np.log1p(train[\"yield\"].astype(float).clip(lower=0.0))\n\n    # simple time-aware validation for early stopping (hold out last year if possible)\n    last_year = int(train[\"year\"].max()) if \"year\" in train.columns else None\n    use_val = last_year is not None and (train[\"year\"] == last_year).sum() >= 50 and (train[\"year\"] != last_year).sum() >= 200\n\n    model = lgb.LGBMRegressor(\n        n_estimators=6000,\n        learning_rate=0.03,\n        num_leaves=127,\n        min_child_samples=20,\n        subsample=0.85,\n        subsample_freq=1,\n        colsample_bytree=0.85,\n        reg_lambda=1.0,\n        random_state=42,\n        n_jobs=-1,\n    )\n\n    if use_val:\n        tr_idx = train[\"year\"] != last_year\n        va_idx = ~tr_idx\n        model.fit(\n            X.loc[tr_idx],\n            y.loc[tr_idx],\n            eval_set=[(X.loc[va_idx], y.loc[va_idx])],\n            eval_metric=\"l1\",\n            callbacks=[lgb.early_stopping(stopping_rounds=300, verbose=False)],\n        )\n        pred_log = model.predict(X_test, num_iteration=model.best_iteration_)\n    else:\n        model.fit(X, y)\n        pred_log = model.predict(X_test)\n\n    test_pred = np.expm1(pred_log)\n    test_pred = np.clip(test_pred, 0.0, None)\n\n    test_out = test.copy()\n    test_out[\"yield\"] = test_pred\n    test_out = test_out[[\"year\", \"month\", \"state\", \"yield\"]]\n    out_path = output_path / \"submission.csv\"\n    test_out.to_csv(out_path, index=False)\n    print(f\"Model trained. Submission saved to: {out_path}\")\n    return out_path\n\n# EVOLVE-BLOCK-END\n\ndef main() -> Path:\n    root = r\"D:\\\u6e05\u534e\u5de5\u7a0b\u535a\u58eb\\C3I\\daguan\\agentic-rl\\mle-openevolve\\experiments\\bean03\\inputs\"\n    out_path = train_and_predict(root)\n    return out_path\n\n\nif __name__ == \"__main__\":\n    main()\n", "language": "python", "parent_id": "9e819819-db5f-4dc0-a56d-d6156309a46c", "generation": 1, "timestamp": 1765792627.4189036, "iteration_found": 2, "metrics": {"combined_score": 0.3761428425045881, "mape": 0.33073301641312935, "rmse": 1218.2912398997594}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 70 lines with 134 lines", "parent_metrics": {"combined_score": 0.4531017397239551, "mape": 0.10554148154084476, "rmse": 598.0350418288939}, "island": 0}, "prompts": {"diff_user": {"system": "You are optimizing machine learning code for predicting Brazilian soybean yield. Goal: minimize MAPE/RMSE on the held-out test set.\n\nHard constraints:\n- Only modify code inside the EVOLVE-BLOCK; do not touch any other code, function signatures, paths, or helpers.\n- Keep the script runnable standalone: read train and test data, write submission.csv, the format of submission.csv must be same with test_answer.csv.\n do not drop all features, you can combine them to generate new features for better performance.\n- You can use any other standard Python libraries for better model.\n\nFreedom:\n- Inside EVOLVE-BLOCK you may change model type (LightGBM/CatBoost/XGBoost/linear/NN/heuristics/FFN), features, and hyperparameters to improve accuracy.\n\nOutput format:\n- Respond ONLY with valid SEARCH/REPLACE diffs for the EVOLVE-BLOCK. If you cannot propose a valid diff, return an empty diff.\n", "user": "# Current Program Information\n- Fitness: 0.4531\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness unchanged at 0.4531\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Unknown changes\n- Metrics: combined_score: 0.4531, mape: 0.1055, rmse: 598.0350\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.4531)\n```python\n\"\"\"\nBaseline model for bean yield prediction\n\nReads ./data/train.csv and ./data/test.csv\nwrites predictions to ./result/submission.csv with columns [year, month, state, yield].\n\nThe EVOLVE-BLOCK marks the scope that OpenEvolve is allowed to tune.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\n# construct real path from judge.py's ROOT\ndef construct_real_path(root):\n    PROJECT_ROOT = Path(root)\n    INPUT_DIR = PROJECT_ROOT\n    OUTPUT_DIR = PROJECT_ROOT.parent / \"outputs\" / \"submission\"\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    TRAIN_PATH = INPUT_DIR / \"train.csv\"\n    TEST_PATH = INPUT_DIR / \"test.csv\"\n\n    return TRAIN_PATH, TEST_PATH, OUTPUT_DIR\n\n# EVOLVE-BLOCK-START\nfrom typing import Dict, Tuple\nimport lightgbm as lgb\nimport pandas as pd\n\ndef encode_state(df: pd.DataFrame, mapping: Dict[str, int] | None = None) -> Tuple[pd.DataFrame, Dict[str, int]]:\n    \"\"\"Encode state column to integer IDs.\"\"\"\n    df = df.copy()\n    if mapping is None:\n        states = sorted(df[\"state\"].unique())\n        mapping = {s: i for i, s in enumerate(states)}\n    df[\"state_enc\"] = df[\"state\"].map(mapping).fillna(-1).astype(int)\n    return df, mapping\n\n\ndef months_since_crop_start(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Map month to a simple crop-phase index.\"\"\"\n    df = df.copy()\n\n    def transform(m: int) -> int:\n        return m - 10 if m >= 10 else m + 2\n\n    df[\"months_since_crop_start\"] = df[\"month\"].apply(transform)\n    return df\n\n\ndef train_and_predict(root) -> Path:\n\n    # do not change this line\n    train_path, test_path, output_path = construct_real_path(root)\n\n    # ---------- read ----------\n    train = pd.read_csv(train_path)\n    test = pd.read_csv(test_path)\n\n    # ---------- encode & transform ----------\n    train, state2idx = encode_state(train)\n    test, _ = encode_state(test, mapping=state2idx)\n    train = months_since_crop_start(train)\n    test = months_since_crop_start(test)\n\n    # ---------- feature selection ----------\n    numeric_kinds = (\"b\", \"i\", \"u\", \"f\", \"c\")\n    candidate_features = [col for col in train.columns if col != \"yield\"]\n    features = [col for col in candidate_features if train[col].dtype.kind in numeric_kinds]\n    target = \"yield\"\n\n    # ---------- train ----------\n    \n    model = lgb.LGBMRegressor(\n        n_estimators=1000,\n        learning_rate=0.05,\n        num_leaves=63,\n        subsample=0.8,\n        colsample_bytree=0.8,\n        random_state=42\n    )\n    \n    model.fit(train[features], train[target])\n\n    # ---------- predict ----------\n    test_pred = model.predict(test[features])\n\n    # ---------- output ----------\n    test_out = test.copy()\n    test_out[\"yield\"] = test_pred\n    test_out = test_out[[\"year\", \"month\", \"state\", \"yield\"]]\n    out_path = output_path / \"submission.csv\"\n    test_out.to_csv(out_path, index=False)\n    print(f\"\u2705 \u6a21\u578b\u8bad\u7ec3\u5b8c\u6210\uff0c\u9884\u6d4b\u7ed3\u679c\u5df2\u4fdd\u5b58\u81f3: {out_path}\")\n    return out_path\n\n# EVOLVE-BLOCK-END\n\ndef main() -> Path:\n    root = r\"D:\\\u6e05\u534e\u5de5\u7a0b\u535a\u58eb\\C3I\\daguan\\agentic-rl\\mle-openevolve\\experiments\\bean03\\inputs\"\n    out_path = train_and_predict(root)\n    return out_path\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\nKey features: Performs well on combined_score (0.4531), Performs well on mape (0.1055), Performs well on rmse (598.0350)\n\n\n\n# Current Program\n```python\n\"\"\"\nBaseline model for bean yield prediction\n\nReads ./data/train.csv and ./data/test.csv\nwrites predictions to ./result/submission.csv with columns [year, month, state, yield].\n\nThe EVOLVE-BLOCK marks the scope that OpenEvolve is allowed to tune.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\n# construct real path from judge.py's ROOT\ndef construct_real_path(root):\n    PROJECT_ROOT = Path(root)\n    INPUT_DIR = PROJECT_ROOT\n    OUTPUT_DIR = PROJECT_ROOT.parent / \"outputs\" / \"submission\"\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    TRAIN_PATH = INPUT_DIR / \"train.csv\"\n    TEST_PATH = INPUT_DIR / \"test.csv\"\n\n    return TRAIN_PATH, TEST_PATH, OUTPUT_DIR\n\n# EVOLVE-BLOCK-START\nfrom typing import Dict, Tuple\nimport lightgbm as lgb\nimport pandas as pd\n\ndef encode_state(df: pd.DataFrame, mapping: Dict[str, int] | None = None) -> Tuple[pd.DataFrame, Dict[str, int]]:\n    \"\"\"Encode state column to integer IDs.\"\"\"\n    df = df.copy()\n    if mapping is None:\n        states = sorted(df[\"state\"].unique())\n        mapping = {s: i for i, s in enumerate(states)}\n    df[\"state_enc\"] = df[\"state\"].map(mapping).fillna(-1).astype(int)\n    return df, mapping\n\n\ndef months_since_crop_start(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Map month to a simple crop-phase index.\"\"\"\n    df = df.copy()\n\n    def transform(m: int) -> int:\n        return m - 10 if m >= 10 else m + 2\n\n    df[\"months_since_crop_start\"] = df[\"month\"].apply(transform)\n    return df\n\n\ndef train_and_predict(root) -> Path:\n\n    # do not change this line\n    train_path, test_path, output_path = construct_real_path(root)\n\n    # ---------- read ----------\n    train = pd.read_csv(train_path)\n    test = pd.read_csv(test_path)\n\n    # ---------- encode & transform ----------\n    train, state2idx = encode_state(train)\n    test, _ = encode_state(test, mapping=state2idx)\n    train = months_since_crop_start(train)\n    test = months_since_crop_start(test)\n\n    # ---------- feature selection ----------\n    numeric_kinds = (\"b\", \"i\", \"u\", \"f\", \"c\")\n    candidate_features = [col for col in train.columns if col != \"yield\"]\n    features = [col for col in candidate_features if train[col].dtype.kind in numeric_kinds]\n    target = \"yield\"\n\n    # ---------- train ----------\n    \n    model = lgb.LGBMRegressor(\n        n_estimators=1000,\n        learning_rate=0.05,\n        num_leaves=63,\n        subsample=0.8,\n        colsample_bytree=0.8,\n        random_state=42\n    )\n    \n    model.fit(train[features], train[target])\n\n    # ---------- predict ----------\n    test_pred = model.predict(test[features])\n\n    # ---------- output ----------\n    test_out = test.copy()\n    test_out[\"yield\"] = test_pred\n    test_out = test_out[[\"year\", \"month\", \"state\", \"yield\"]]\n    out_path = output_path / \"submission.csv\"\n    test_out.to_csv(out_path, index=False)\n    print(f\"\u2705 \u6a21\u578b\u8bad\u7ec3\u5b8c\u6210\uff0c\u9884\u6d4b\u7ed3\u679c\u5df2\u4fdd\u5b58\u81f3: {out_path}\")\n    return out_path\n\n# EVOLVE-BLOCK-END\n\ndef main() -> Path:\n    root = r\"D:\\\u6e05\u534e\u5de5\u7a0b\u535a\u58eb\\C3I\\daguan\\agentic-rl\\mle-openevolve\\experiments\\bean03\\inputs\"\n    out_path = train_and_predict(root)\n    return out_path\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["<<<<<<< SEARCH\nfrom typing import Dict, Tuple\nimport lightgbm as lgb\nimport pandas as pd\n\ndef encode_state(df: pd.DataFrame, mapping: Dict[str, int] | None = None) -> Tuple[pd.DataFrame, Dict[str, int]]:\n    \"\"\"Encode state column to integer IDs.\"\"\"\n    df = df.copy()\n    if mapping is None:\n        states = sorted(df[\"state\"].unique())\n        mapping = {s: i for i, s in enumerate(states)}\n    df[\"state_enc\"] = df[\"state\"].map(mapping).fillna(-1).astype(int)\n    return df, mapping\n\n\ndef months_since_crop_start(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Map month to a simple crop-phase index.\"\"\"\n    df = df.copy()\n\n    def transform(m: int) -> int:\n        return m - 10 if m >= 10 else m + 2\n\n    df[\"months_since_crop_start\"] = df[\"month\"].apply(transform)\n    return df\n\n\ndef train_and_predict(root) -> Path:\n\n    # do not change this line\n    train_path, test_path, output_path = construct_real_path(root)\n\n    # ---------- read ----------\n    train = pd.read_csv(train_path)\n    test = pd.read_csv(test_path)\n\n    # ---------- encode & transform ----------\n    train, state2idx = encode_state(train)\n    test, _ = encode_state(test, mapping=state2idx)\n    train = months_since_crop_start(train)\n    test = months_since_crop_start(test)\n\n    # ---------- feature selection ----------\n    numeric_kinds = (\"b\", \"i\", \"u\", \"f\", \"c\")\n    candidate_features = [col for col in train.columns if col != \"yield\"]\n    features = [col for col in candidate_features if train[col].dtype.kind in numeric_kinds]\n    target = \"yield\"\n\n    # ---------- train ----------\n    \n    model = lgb.LGBMRegressor(\n        n_estimators=1000,\n        learning_rate=0.05,\n        num_leaves=63,\n        subsample=0.8,\n        colsample_bytree=0.8,\n        random_state=42\n    )\n    \n    model.fit(train[features], train[target])\n\n    # ---------- predict ----------\n    test_pred = model.predict(test[features])\n\n    # ---------- output ----------\n    test_out = test.copy()\n    test_out[\"yield\"] = test_pred\n    test_out = test_out[[\"year\", \"month\", \"state\", \"yield\"]]\n    out_path = output_path / \"submission.csv\"\n    test_out.to_csv(out_path, index=False)\n    print(f\"\u2705 \u6a21\u578b\u8bad\u7ec3\u5b8c\u6210\uff0c\u9884\u6d4b\u7ed3\u679c\u5df2\u4fdd\u5b58\u81f3: {out_path}\")\n    return out_path\n=======\nfrom typing import Dict, Tuple, List\nimport numpy as np\nimport lightgbm as lgb\nimport pandas as pd\n\n\ndef encode_state(df: pd.DataFrame, mapping: Dict[str, int] | None = None) -> Tuple[pd.DataFrame, Dict[str, int]]:\n    df = df.copy()\n    if mapping is None:\n        states = sorted(df[\"state\"].astype(str).unique())\n        mapping = {s: i for i, s in enumerate(states)}\n    df[\"state_enc\"] = df[\"state\"].astype(str).map(mapping).fillna(-1).astype(int)\n    return df, mapping\n\n\ndef months_since_crop_start(df: pd.DataFrame) -> pd.DataFrame:\n    df = df.copy()\n\n    def transform(m: int) -> int:\n        return m - 10 if m >= 10 else m + 2\n\n    df[\"months_since_crop_start\"] = df[\"month\"].astype(int).apply(transform)\n    return df\n\n\ndef add_time_features(df: pd.DataFrame) -> pd.DataFrame:\n    df = df.copy()\n    m = df[\"month\"].astype(float)\n    df[\"month_sin\"] = np.sin(2.0 * np.pi * m / 12.0)\n    df[\"month_cos\"] = np.cos(2.0 * np.pi * m / 12.0)\n    df[\"month_sq\"] = m * m\n    # simple interactions that often help tree models\n    df[\"state_x_month\"] = df[\"state_enc\"].astype(float) * m\n    df[\"state_x_phase\"] = df[\"state_enc\"].astype(float) * df[\"months_since_crop_start\"].astype(float)\n    return df\n\n\ndef _target_encode(\n    train: pd.DataFrame,\n    test: pd.DataFrame,\n    cols: List[str],\n    target: str = \"yield\",\n    alpha: float = 20.0,\n) -> Tuple[pd.Series, pd.Series]:\n    \"\"\"Smoothed target encoding computed on full train; mapped onto train/test.\"\"\"\n    global_mean = float(train[target].mean())\n    agg = train.groupby(cols, dropna=False)[target].agg([\"mean\", \"count\"]).reset_index()\n    agg[\"te\"] = (agg[\"mean\"] * agg[\"count\"] + global_mean * alpha) / (agg[\"count\"] + alpha)\n    key = cols\n    tr = train[key].merge(agg[key + [\"te\"]], on=key, how=\"left\")[\"te\"].fillna(global_mean)\n    te = test[key].merge(agg[key + [\"te\"]], on=key, how=\"left\")[\"te\"].fillna(global_mean)\n    return tr, te\n\n\ndef train_and_predict(root) -> Path:\n    # do not change this line\n    train_path, test_path, output_path = construct_real_path(root)\n\n    train = pd.read_csv(train_path)\n    test = pd.read_csv(test_path)\n\n    # base transforms\n    train, state2idx = encode_state(train)\n    test, _ = encode_state(test, mapping=state2idx)\n    train = months_since_crop_start(train)\n    test = months_since_crop_start(test)\n    train = add_time_features(train)\n    test = add_time_features(test)\n\n    # smoothed target encodings (strong for region + season)\n    for cols in ([\"state_enc\"], [\"month\"], [\"year\"], [\"state_enc\", \"month\"], [\"state_enc\", \"months_since_crop_start\"]):\n        tr_te, te_te = _target_encode(train, test, cols=cols, target=\"yield\", alpha=30.0)\n        name = \"te_\" + \"_\".join(cols)\n        train[name] = tr_te.astype(float)\n        test[name] = te_te.astype(float)\n\n    # feature selection (numeric only; keep engineered TE/time features)\n    numeric_kinds = (\"b\", \"i\", \"u\", \"f\", \"c\")\n    candidate_features = [c for c in train.columns if c != \"yield\"]\n    features = [c for c in candidate_features if train[c].dtype.kind in numeric_kinds]\n\n    X = train[features].copy()\n    X_test = test[features].copy()\n\n    # robust missing handling\n    med = X.median(numeric_only=True)\n    X = X.fillna(med)\n    X_test = X_test.fillna(med)\n\n    # log-transform helps RMSE+MAPE tradeoff; clip at 0 on inverse\n    y = np.log1p(train[\"yield\"].astype(float).clip(lower=0.0))\n\n    # simple time-aware validation for early stopping (hold out last year if possible)\n    last_year = int(train[\"year\"].max()) if \"year\" in train.columns else None\n    use_val = last_year is not None and (train[\"year\"] == last_year).sum() >= 50 and (train[\"year\"] != last_year).sum() >= 200\n\n    model = lgb.LGBMRegressor(\n        n_estimators=6000,\n        learning_rate=0.03,\n        num_leaves=127,\n        min_child_samples=20,\n        subsample=0.85,\n        subsample_freq=1,\n        colsample_bytree=0.85,\n        reg_lambda=1.0,\n        random_state=42,\n        n_jobs=-1,\n    )\n\n    if use_val:\n        tr_idx = train[\"year\"] != last_year\n        va_idx = ~tr_idx\n        model.fit(\n            X.loc[tr_idx],\n            y.loc[tr_idx],\n            eval_set=[(X.loc[va_idx], y.loc[va_idx])],\n            eval_metric=\"l1\",\n            callbacks=[lgb.early_stopping(stopping_rounds=300, verbose=False)],\n        )\n        pred_log = model.predict(X_test, num_iteration=model.best_iteration_)\n    else:\n        model.fit(X, y)\n        pred_log = model.predict(X_test)\n\n    test_pred = np.expm1(pred_log)\n    test_pred = np.clip(test_pred, 0.0, None)\n\n    test_out = test.copy()\n    test_out[\"yield\"] = test_pred\n    test_out = test_out[[\"year\", \"month\", \"state\", \"yield\"]]\n    out_path = output_path / \"submission.csv\"\n    test_out.to_csv(out_path, index=False)\n    print(f\"Model trained. Submission saved to: {out_path}\")\n    return out_path\n>>>>>>> REPLACE"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}