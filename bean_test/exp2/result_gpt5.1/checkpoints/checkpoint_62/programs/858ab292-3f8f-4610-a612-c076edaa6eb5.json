{"id": "858ab292-3f8f-4610-a612-c076edaa6eb5", "code": "\"\"\"\nBaseline model for bean_test exp2.\n\nReads ./input/train.csv and ./input/test.csv, performs simple preprocessing\n(state encoding + months_since_crop_start), trains a LightGBM regressor, and\nwrites predictions to ./output/submission.csv with columns [year, month, state, yield].\n\nThe EVOLVE-BLOCK marks the scope that OpenEvolve is allowed to tune.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\n# Paths\n# PROJECT_ROOT = Path(__file__).resolve().parent\nPROJECT_ROOT = Path(r\"D:\\\u6e05\u534e\u5de5\u7a0b\u535a\u58eb\\C3I\\AutoMLAgent\\openevolve\\bean_test\\exp1\")\nINPUT_DIR = PROJECT_ROOT / \"input\"\nOUTPUT_DIR = PROJECT_ROOT / \"output\"\nOUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n\nTRAIN_PATH = INPUT_DIR / \"train.csv\"\nTEST_PATH = INPUT_DIR / \"test.csv\"\n\n# EVOLVE-BLOCK-START\nfrom typing import Dict, Tuple\nimport numpy as np\nimport lightgbm as lgb\nimport pandas as pd\n\ndef encode_state(df: pd.DataFrame, mapping: Dict[str, int] | None = None) -> Tuple[pd.DataFrame, Dict[str, int]]:\n    \"\"\"Encode state column to integer IDs.\"\"\"\n    df = df.copy()\n    if mapping is None:\n        states = sorted(df[\"state\"].unique())\n        mapping = {s: i for i, s in enumerate(states)}\n    df[\"state_enc\"] = df[\"state\"].map(mapping).fillna(-1).astype(int)\n    return df, mapping\n\n\ndef months_since_crop_start(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Map month to a simple crop-phase index.\"\"\"\n    df = df.copy()\n\n    def transform(m: int) -> int:\n        return m - 10 if m >= 10 else m + 2\n\n    df[\"months_since_crop_start\"] = df[\"month\"].apply(transform)\n    return df\n\n\ndef add_target_stats(train: pd.DataFrame, test: pd.DataFrame) -> Tuple[pd.DataFrame, pd.DataFrame]:\n    \"\"\"Add simple target-encoding style statistics based only on the training data.\"\"\"\n    train = train.copy()\n    test = test.copy()\n\n    global_mean = train[\"yield\"].mean()\n    state_mean = train.groupby(\"state\")[\"yield\"].mean()\n    month_mean = train.groupby(\"month\")[\"yield\"].mean()\n    year_mean = train.groupby(\"year\")[\"yield\"].mean()\n    state_month_mean = train.groupby([\"state\", \"month\"])[\"yield\"].mean().to_dict()\n    state_year_mean = train.groupby([\"state\", \"year\"])[\"yield\"].mean().to_dict()\n\n    for df in (train, test):\n        df[\"state_yield_mean\"] = df[\"state\"].map(state_mean)\n        df[\"month_yield_mean\"] = df[\"month\"].map(month_mean)\n        df[\"year_yield_mean\"] = df[\"year\"].map(year_mean)\n\n        key_sm = list(zip(df[\"state\"], df[\"month\"]))\n        key_sy = list(zip(df[\"state\"], df[\"year\"]))\n        df[\"state_month_yield_mean\"] = pd.Series(key_sm, index=df.index).map(state_month_mean)\n        df[\"state_year_yield_mean\"] = pd.Series(key_sy, index=df.index).map(state_year_mean)\n\n        df[\n            [\n                \"state_yield_mean\",\n                \"month_yield_mean\",\n                \"year_yield_mean\",\n                \"state_month_yield_mean\",\n                \"state_year_yield_mean\",\n            ]\n        ] = df[\n            [\n                \"state_yield_mean\",\n                \"month_yield_mean\",\n                \"year_yield_mean\",\n                \"state_month_yield_mean\",\n                \"state_year_yield_mean\",\n            ]\n        ].fillna(global_mean)\n\n    return train, test\n\n\ndef train_and_predict() -> Path:\n\n    # ---------- read ----------\n    train = pd.read_csv(TRAIN_PATH)\n    test = pd.read_csv(TEST_PATH)\n\n    # ---------- encode & transform ----------\n    train, state2idx = encode_state(train)\n    test, _ = encode_state(test, mapping=state2idx)\n    train = months_since_crop_start(train)\n    test = months_since_crop_start(test)\n    train, test = add_target_stats(train, test)\n\n    # ---------- feature selection ----------\n    numeric_kinds = (\"b\", \"i\", \"u\", \"f\", \"c\")\n    candidate_features = [col for col in train.columns if col != \"yield\"]\n    features = [col for col in candidate_features if train[col].dtype.kind in numeric_kinds]\n    target = \"yield\"\n\n    # ---------- train ----------\n    models = []\n    for seed in (42, 7, 2024, 99, 123):\n        m = lgb.LGBMRegressor(\n            n_estimators=1500,\n            learning_rate=0.03,\n            num_leaves=64,\n            min_child_samples=10,\n            subsample=0.9,\n            colsample_bytree=0.9,\n            reg_alpha=0.1,\n            reg_lambda=0.2,\n            random_state=seed,\n            n_jobs=-1,\n        )\n        # Treat encoded state as categorical to allow non-ordinal splits\n        m.fit(train[features], train[target], categorical_feature=[\"state_enc\"])\n        models.append(m)\n\n    # ---------- predict ----------\n    train_preds = np.column_stack([m.predict(train[features]) for m in models])\n    test_preds = np.column_stack([m.predict(test[features]) for m in models])\n    train_pred_mean = train_preds.mean(axis=1)\n    test_pred_mean = test_preds.mean(axis=1)\n\n    # linear calibration of ensemble predictions on training data (2-parameter fit)\n    y_true = train[target].values\n    cov = np.cov(train_pred_mean, y_true, bias=True)[0, 1]\n    var = np.var(train_pred_mean)\n    if var > 0:\n        b = cov / var\n        a = y_true.mean() - b * train_pred_mean.mean()\n        test_pred = a + b * test_pred_mean\n    else:\n        test_pred = test_pred_mean\n\n    # clip calibrated predictions to the observed training range\n    y_min, y_max = y_true.min(), y_true.max()\n    test_pred = np.clip(test_pred, y_min, y_max)\n\n    # ---------- output ----------\n    test_out = test.copy()\n    test_out[\"yield\"] = test_pred\n    test_out = test_out[[\"year\", \"month\", \"state\", \"yield\"]]\n    out_path = OUTPUT_DIR / \"submission.csv\"\n    test_out.to_csv(out_path, index=False)\n    print(f\"Model training finished, predictions saved to: {out_path}\")\n    return out_path\n\n# EVOLVE-BLOCK-END\n\ndef main() -> Path:\n    out_path = train_and_predict()\n    print(f\"Model trained; predictions saved to {out_path}\")\n    return out_path\n\n\nif __name__ == \"__main__\":\n    main()\n", "language": "python", "parent_id": "56cf58d9-7498-40d0-8fdf-cdb1bd47ec19", "generation": 10, "timestamp": 1764744907.0551178, "iteration_found": 53, "metrics": {"combined_score": 0.94048694567949, "mape": 1.8383359904872665e-05, "rmse": 0.13508373351251188}, "complexity": 0.0, "diversity": 0.0, "metadata": {"island": 0}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}