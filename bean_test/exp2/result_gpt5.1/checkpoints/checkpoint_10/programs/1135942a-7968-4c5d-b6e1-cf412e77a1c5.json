{"id": "1135942a-7968-4c5d-b6e1-cf412e77a1c5", "code": "\"\"\"\nBaseline model for bean_test exp2.\n\nReads ./input/train.csv and ./input/test.csv, performs simple preprocessing\n(state encoding + months_since_crop_start), trains a LightGBM regressor, and\nwrites predictions to ./output/submission.csv with columns [year, month, state, yield].\n\nThe EVOLVE-BLOCK marks the scope that OpenEvolve is allowed to tune.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\n# Paths\n# PROJECT_ROOT = Path(__file__).resolve().parent\nPROJECT_ROOT = Path(r\"D:\\\u6e05\u534e\u5de5\u7a0b\u535a\u58eb\\C3I\\AutoMLAgent\\openevolve\\bean_test\\exp1\")\nINPUT_DIR = PROJECT_ROOT / \"input\"\nOUTPUT_DIR = PROJECT_ROOT / \"output\"\nOUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n\nTRAIN_PATH = INPUT_DIR / \"train.csv\"\nTEST_PATH = INPUT_DIR / \"test.csv\"\n\n# EVOLVE-BLOCK-START\nfrom typing import Dict, Tuple\nimport numpy as np\nimport lightgbm as lgb\nimport pandas as pd\n\ndef encode_state(df: pd.DataFrame, mapping: Dict[str, int] | None = None) -> Tuple[pd.DataFrame, Dict[str, int]]:\n    \"\"\"Encode state column to integer IDs.\"\"\"\n    df = df.copy()\n    if mapping is None:\n        states = sorted(df[\"state\"].unique())\n        mapping = {s: i for i, s in enumerate(states)}\n    df[\"state_enc\"] = df[\"state\"].map(mapping).fillna(-1).astype(int)\n    return df, mapping\n\n\ndef months_since_crop_start(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Map month to a simple crop-phase index.\"\"\"\n    df = df.copy()\n\n    def transform(m: int) -> int:\n        return m - 10 if m >= 10 else m + 2\n\n    df[\"months_since_crop_start\"] = df[\"month\"].apply(transform)\n    return df\n\n\ndef train_and_predict() -> Path:\n\n    # ---------- read ----------\n    train = pd.read_csv(TRAIN_PATH)\n    test = pd.read_csv(TEST_PATH)\n\n    # ---------- encode & transform ----------\n    train, state2idx = encode_state(train)\n    test, _ = encode_state(test, mapping=state2idx)\n    train = months_since_crop_start(train)\n    test = months_since_crop_start(test)\n\n    # ---------- feature selection ----------\n    numeric_kinds = (\"b\", \"i\", \"u\", \"f\", \"c\")\n    candidate_features = [col for col in train.columns if col != \"yield\"]\n    features = [col for col in candidate_features if train[col].dtype.kind in numeric_kinds]\n    target = \"yield\"\n\n    # ---------- train ----------\n    model = lgb.LGBMRegressor(\n        n_estimators=1000,\n        learning_rate=0.05,\n        num_leaves=63,\n        subsample=0.8,\n        colsample_bytree=0.8,\n        random_state=42,\n    )\n    model.fit(train[features], train[target])\n\n    # ---------- predict ----------\n    test_pred = model.predict(test[features])\n    # Clip predictions to non-negative values (yields cannot be negative)\n    test_pred = np.clip(test_pred, a_min=0.0, a_max=None)\n\n    # ---------- output ----------\n    test_out = test.copy()\n    test_out[\"yield\"] = test_pred\n    test_out = test_out[[\"year\", \"month\", \"state\", \"yield\"]]\n    out_path = OUTPUT_DIR / \"submission.csv\"\n    test_out.to_csv(out_path, index=False)\n    print(f\"\u2705 \u6a21\u578b\u8bad\u7ec3\u5b8c\u6210\uff0c\u9884\u6d4b\u7ed3\u679c\u5df2\u4fdd\u5b58\u81f3: {out_path}\")\n    return out_path\n\n# EVOLVE-BLOCK-END\n\ndef main() -> Path:\n    out_path = train_and_predict()\n    print(f\"Model trained; predictions saved to {out_path}\")\n    return out_path\n\n\nif __name__ == \"__main__\":\n    main()\n", "language": "python", "parent_id": "8a3ed884-d9d4-4ba9-988c-779c2bf09703", "generation": 3, "timestamp": 1764739983.0956712, "iteration_found": 5, "metrics": {"combined_score": 0.7867218637397513, "mape": 8.218379499041217e-05, "rmse": 0.7436004060451427}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 3 lines with 4 lines\nChange 2: Replace 2 lines with 4 lines", "parent_metrics": {"combined_score": 0.7867218637397513, "mape": 8.218379499041217e-05, "rmse": 0.7436004060451427}, "island": 0}, "prompts": {"diff_user": {"system": "You are optimizing bean_test exp2 for Brazilian soybean yield. Goal: minimize MAPE/RMSE on the held-out test set used by evaluator.py.\n\nHard constraints:\n- Only modify code inside the EVOLVE-BLOCK; do not touch any other code, function signatures, paths, or helpers.\n- Keep the script runnable standalone: read ./input/train.csv & ./input/test.csv; write ./output/submission.csv with columns [year, month, state, yield].\n- Preserve feature pipeline basics (state encoding, months_since_crop_start); do not drop all features.\n- You can use any other standard Python libraries for better model.\n\nFreedom:\n- Inside EVOLVE-BLOCK you may change model type (LightGBM/CatBoost/XGBoost/linear/NN/heuristics/FFN), features, and hyperparameters to improve accuracy.\n\nOutput format:\n- Respond ONLY with valid SEARCH/REPLACE diffs for the EVOLVE-BLOCK. If you cannot propose a valid diff, return an empty diff.\n", "user": "# Current Program Information\n- Fitness: 0.7867\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness improved: 0.6046 \u2192 0.7867\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Change 1: Replace 67 lines with 96 lines\n- Metrics: combined_score: 0.6046, mape: 0.0009, rmse: 3.7611\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Change 1: Replace 91 lines with 65 lines\n- Metrics: combined_score: 0.7867, mape: 0.0001, rmse: 0.7436\n- Outcome: Improvement in all metrics\n\n### Attempt 1\n- Changes: Unknown changes\n- Metrics: combined_score: 0.7867, mape: 0.0001, rmse: 0.7436\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.7867)\n```python\n\"\"\"\nBaseline model for bean_test exp2.\n\nReads ./input/train.csv and ./input/test.csv, performs simple preprocessing\n(state encoding + months_since_crop_start), trains a LightGBM regressor, and\nwrites predictions to ./output/submission.csv with columns [year, month, state, yield].\n\nThe EVOLVE-BLOCK marks the scope that OpenEvolve is allowed to tune.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\n# Paths\n# PROJECT_ROOT = Path(__file__).resolve().parent\nPROJECT_ROOT = Path(r\"D:\\\u6e05\u534e\u5de5\u7a0b\u535a\u58eb\\C3I\\AutoMLAgent\\openevolve\\bean_test\\exp1\")\nINPUT_DIR = PROJECT_ROOT / \"input\"\nOUTPUT_DIR = PROJECT_ROOT / \"output\"\nOUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n\nTRAIN_PATH = INPUT_DIR / \"train.csv\"\nTEST_PATH = INPUT_DIR / \"test.csv\"\n\n# EVOLVE-BLOCK-START\nfrom typing import Dict, Tuple\nimport lightgbm as lgb\nimport pandas as pd\n\ndef encode_state(df: pd.DataFrame, mapping: Dict[str, int] | None = None) -> Tuple[pd.DataFrame, Dict[str, int]]:\n    \"\"\"Encode state column to integer IDs.\"\"\"\n    df = df.copy()\n    if mapping is None:\n        states = sorted(df[\"state\"].unique())\n        mapping = {s: i for i, s in enumerate(states)}\n    df[\"state_enc\"] = df[\"state\"].map(mapping).fillna(-1).astype(int)\n    return df, mapping\n\n\ndef months_since_crop_start(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Map month to a simple crop-phase index.\"\"\"\n    df = df.copy()\n\n    def transform(m: int) -> int:\n        return m - 10 if m >= 10 else m + 2\n\n    df[\"months_since_crop_start\"] = df[\"month\"].apply(transform)\n    return df\n\n\ndef train_and_predict() -> Path:\n\n    # ---------- read ----------\n    train = pd.read_csv(TRAIN_PATH)\n    test = pd.read_csv(TEST_PATH)\n\n    # ---------- encode & transform ----------\n    train, state2idx = encode_state(train)\n    test, _ = encode_state(test, mapping=state2idx)\n    train = months_since_crop_start(train)\n    test = months_since_crop_start(test)\n\n    # ---------- feature selection ----------\n    numeric_kinds = (\"b\", \"i\", \"u\", \"f\", \"c\")\n    candidate_features = [col for col in train.columns if col != \"yield\"]\n    features = [col for col in candidate_features if train[col].dtype.kind in numeric_kinds]\n    target = \"yield\"\n\n    # ---------- train ----------\n    \n    model = lgb.LGBMRegressor(\n        n_estimators=1000,\n        learning_rate=0.05,\n        num_leaves=63,\n        subsample=0.8,\n        colsample_bytree=0.8,\n        random_state=42\n    )\n    \n    model.fit(train[features], train[target])\n\n    # ---------- predict ----------\n    test_pred = model.predict(test[features])\n\n    # ---------- output ----------\n    test_out = test.copy()\n    test_out[\"yield\"] = test_pred\n    test_out = test_out[[\"year\", \"month\", \"state\", \"yield\"]]\n    out_path = OUTPUT_DIR / \"submission.csv\"\n    test_out.to_csv(out_path, index=False)\n    print(f\"\u2705 \u6a21\u578b\u8bad\u7ec3\u5b8c\u6210\uff0c\u9884\u6d4b\u7ed3\u679c\u5df2\u4fdd\u5b58\u81f3: {out_path}\")\n    return out_path\n\n# EVOLVE-BLOCK-END\n\ndef main() -> Path:\n    out_path = train_and_predict()\n    print(f\"Model trained; predictions saved to {out_path}\")\n    return out_path\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\nKey features: Performs well on combined_score (0.7867), Performs well on mape (0.0001), Performs well on rmse (0.7436)\n\n### Program 2 (Score: 0.7867)\n```python\n\"\"\"\nBaseline model for bean_test exp2.\n\nReads ./input/train.csv and ./input/test.csv, performs simple preprocessing\n(state encoding + months_since_crop_start), trains a LightGBM regressor, and\nwrites predictions to ./output/submission.csv with columns [year, month, state, yield].\n\nThe EVOLVE-BLOCK marks the scope that OpenEvolve is allowed to tune.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\n# Paths\n# PROJECT_ROOT = Path(__file__).resolve().parent\nPROJECT_ROOT = Path(r\"D:\\\u6e05\u534e\u5de5\u7a0b\u535a\u58eb\\C3I\\AutoMLAgent\\openevolve\\bean_test\\exp1\")\nINPUT_DIR = PROJECT_ROOT / \"input\"\nOUTPUT_DIR = PROJECT_ROOT / \"output\"\nOUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n\nTRAIN_PATH = INPUT_DIR / \"train.csv\"\nTEST_PATH = INPUT_DIR / \"test.csv\"\n\n# EVOLVE-BLOCK-START\nfrom typing import Dict, Tuple\nimport lightgbm as lgb\nimport pandas as pd\n\ndef encode_state(df: pd.DataFrame, mapping: Dict[str, int] | None = None) -> Tuple[pd.DataFrame, Dict[str, int]]:\n    \"\"\"Encode state column to integer IDs.\"\"\"\n    df = df.copy()\n    if mapping is None:\n        states = sorted(df[\"state\"].unique())\n        mapping = {s: i for i, s in enumerate(states)}\n    df[\"state_enc\"] = df[\"state\"].map(mapping).fillna(-1).astype(int)\n    return df, mapping\n\n\ndef months_since_crop_start(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Map month to a simple crop-phase index.\"\"\"\n    df = df.copy()\n\n    def transform(m: int) -> int:\n        return m - 10 if m >= 10 else m + 2\n\n    df[\"months_since_crop_start\"] = df[\"month\"].apply(transform)\n    return df\n\n\ndef train_and_predict() -> Path:\n\n    # ---------- read ----------\n    train = pd.read_csv(TRAIN_PATH)\n    test = pd.read_csv(TEST_PATH)\n\n    # ---------- encode & transform ----------\n    train, state2idx = encode_state(train)\n    test, _ = encode_state(test, mapping=state2idx)\n    train = months_since_crop_start(train)\n    test = months_since_crop_start(test)\n\n    # ---------- feature selection ----------\n    numeric_kinds = (\"b\", \"i\", \"u\", \"f\", \"c\")\n    candidate_features = [col for col in train.columns if col != \"yield\"]\n    features = [col for col in candidate_features if train[col].dtype.kind in numeric_kinds]\n    target = \"yield\"\n\n    # ---------- train ----------\n    model = lgb.LGBMRegressor(\n        n_estimators=1000,\n        learning_rate=0.05,\n        num_leaves=63,\n        subsample=0.8,\n        colsample_bytree=0.8,\n        random_state=42,\n    )\n    model.fit(train[features], train[target])\n\n    # ---------- predict ----------\n    test_pred = model.predict(test[features])\n\n    # ---------- output ----------\n    test_out = test.copy()\n    test_out[\"yield\"] = test_pred\n    test_out = test_out[[\"year\", \"month\", \"state\", \"yield\"]]\n    out_path = OUTPUT_DIR / \"submission.csv\"\n    test_out.to_csv(out_path, index=False)\n    print(f\"\u2705 \u6a21\u578b\u8bad\u7ec3\u5b8c\u6210\uff0c\u9884\u6d4b\u7ed3\u679c\u5df2\u4fdd\u5b58\u81f3: {out_path}\")\n    return out_path\n\n# EVOLVE-BLOCK-END\n\ndef main() -> Path:\n    out_path = train_and_predict()\n    print(f\"Model trained; predictions saved to {out_path}\")\n    return out_path\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\nKey features: Performs well on combined_score (0.7867), Performs well on mape (0.0001), Performs well on rmse (0.7436)\n\n### Program 3 (Score: 0.6046)\n```python\n\"\"\"\nBaseline model for bean_test exp2.\n\nReads ./input/train.csv and ./input/test.csv, performs simple preprocessing\n(state encoding + months_since_crop_start), trains a LightGBM regressor, and\nwrites predictions to ./output/submission.csv with columns [year, month, state, yield].\n\nThe EVOLVE-BLOCK marks the scope that OpenEvolve is allowed to tune.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\n# Paths\n# PROJECT_ROOT = Path(__file__).resolve().parent\nPROJECT_ROOT = Path(r\"D:\\\u6e05\u534e\u5de5\u7a0b\u535a\u58eb\\C3I\\AutoMLAgent\\openevolve\\bean_test\\exp1\")\nINPUT_DIR = PROJECT_ROOT / \"input\"\nOUTPUT_DIR = PROJECT_ROOT / \"output\"\nOUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n\nTRAIN_PATH = INPUT_DIR / \"train.csv\"\nTEST_PATH = INPUT_DIR / \"test.csv\"\n\n# EVOLVE-BLOCK-START\nfrom typing import Dict, Tuple\nimport numpy as np\nimport lightgbm as lgb\nimport pandas as pd\n\n\ndef encode_state(\n    df: pd.DataFrame, mapping: Dict[str, int] | None = None\n) -> Tuple[pd.DataFrame, Dict[str, int]]:\n    \"\"\"Encode state column to integer IDs.\"\"\"\n    df = df.copy()\n    if mapping is None:\n        states = sorted(df[\"state\"].unique())\n        mapping = {s: i for i, s in enumerate(states)}\n    df[\"state_enc\"] = df[\"state\"].map(mapping).fillna(-1).astype(int)\n    return df, mapping\n\n\ndef months_since_crop_start(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Map month to a simple crop-phase index.\"\"\"\n    df = df.copy()\n\n    def transform(m: int) -> int:\n        return m - 10 if m >= 10 else m + 2\n\n    df[\"months_since_crop_start\"] = df[\"month\"].apply(transform)\n    return df\n\n\ndef add_calendar_features(df: pd.DataFrame, min_year: int) -> pd.DataFrame:\n    \"\"\"Add simple cyclical/calendar features.\"\"\"\n    df = df.copy()\n    # month as angle on the circle\n    angle = 2.0 * np.pi * (df[\"month\"] - 1) / 12.0\n    df[\"month_sin\"] = np.sin(angle)\n    df[\"month_cos\"] = np.cos(angle)\n    # year normalized so that scale is reasonable\n    df[\"year_norm\"] = df[\"year\"] - min_year\n    return df\n\n\ndef train_and_predict() -> Path:\n    # ---------- read ----------\n    train = pd.read_csv(TRAIN_PATH)\n    test = pd.read_csv(TEST_PATH)\n\n    # ---------- shared stats for transforms ----------\n    min_year = pd.concat([train[\"year\"], test[\"year\"]]).min()\n\n    # ---------- encode & transform ----------\n    train, state2idx = encode_state(train)\n    test, _ = encode_state(test, mapping=state2idx)\n\n    train = months_since_crop_start(train)\n    test = months_since_crop_start(test)\n\n    train = add_calendar_features(train, min_year)\n    test = add_calendar_features(test, min_year)\n\n    # ---------- feature selection ----------\n    numeric_kinds = (\"b\", \"i\", \"u\", \"f\", \"c\")\n    exclude_cols = {\"yield\", \"state\"}\n    features = [\n        col\n        for col in train.columns\n        if col not in exclude_cols and train[col].dtype.kind in numeric_kinds\n    ]\n    target = \"yield\"\n\n    # ---------- train ----------\n    model = lgb.LGBMRegressor(\n        n_estimators=1200,\n        learning_rate=0.03,\n        num_leaves=31,\n        max_depth=-1,\n        subsample=0.9,\n        colsample_bytree=0.9,\n        min_child_samples=20,\n        reg_lambda=0.1,\n        random_state=42,\n        n_jobs=-1,\n    )\n\n    model.fit(train[features], train[target], categorical_feature=[\"state_enc\"])\n\n    # ---------- predict ----------\n    test_pred = model.predict(test[features])\n\n    # ---------- output ----------\n    test_out = test.copy()\n    test_out[\"yield\"] = test_pred\n    test_out = test_out[[\"year\", \"month\", \"state\", \"yield\"]]\n    out_path = OUTPUT_DIR / \"submission.csv\"\n    test_out.to_csv(out_path, index=False)\n    print(f\"Model training finished. Predictions saved to: {out_path}\")\n    return out_path\n\n# EVOLVE-BLOCK-END\n\ndef main() -> Path:\n    out_path = train_and_predict()\n    print(f\"Model trained; predictions saved to {out_path}\")\n    return out_path\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\nKey features: Performs well on combined_score (0.6046), Performs well on mape (0.0009), Performs well on rmse (3.7611)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\n\"\"\"\nBaseline model for bean_test exp2.\n\nReads ./input/train.csv and ./input/test.csv, performs simple preprocessing\n(state encoding + months_since_crop_start), trains a LightGBM regressor, and\nwrites predictions to ./output/submission.csv with columns [year, month, state, yield].\n\nThe EVOLVE-BLOCK marks the scope that OpenEvolve is allowed to tune.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\n# Paths\n# PROJECT_ROOT = Path(__file__).resolve().parent\nPROJECT_ROOT = Path(r\"D:\\\u6e05\u534e\u5de5\u7a0b\u535a\u58eb\\C3I\\AutoMLAgent\\openevolve\\bean_test\\exp1\")\nINPUT_DIR = PROJECT_ROOT / \"input\"\nOUTPUT_DIR = PROJECT_ROOT / \"output\"\nOUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n\nTRAIN_PATH = INPUT_DIR / \"train.csv\"\nTEST_PATH = INPUT_DIR / \"test.csv\"\n\n# EVOLVE-BLOCK-START\nfrom typing import Dict, Tuple\nimport lightgbm as lgb\nimport pandas as pd\n\ndef encode_state(df: pd.DataFrame, mapping: Dict[str, int] | None = None) -> Tuple[pd.DataFrame, Dict[str, int]]:\n    \"\"\"Encode state column to integer IDs.\"\"\"\n    df = df.copy()\n    if mapping is None:\n        states = sorted(df[\"state\"].unique())\n        mapping = {s: i for i, s in enumerate(states)}\n    df[\"state_enc\"] = df[\"state\"].map(mapping).fillna(-1).astype(int)\n    return df, mapping\n\n\ndef months_since_crop_start(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Map month to a simple crop-phase index.\"\"\"\n    df = df.copy()\n\n    def transform(m: int) -> int:\n        return m - 10 if m >= 10 else m + 2\n\n    df[\"months_since_crop_start\"] = df[\"month\"].apply(transform)\n    return df\n\n\ndef train_and_predict() -> Path:\n\n    # ---------- read ----------\n    train = pd.read_csv(TRAIN_PATH)\n    test = pd.read_csv(TEST_PATH)\n\n    # ---------- encode & transform ----------\n    train, state2idx = encode_state(train)\n    test, _ = encode_state(test, mapping=state2idx)\n    train = months_since_crop_start(train)\n    test = months_since_crop_start(test)\n\n    # ---------- feature selection ----------\n    numeric_kinds = (\"b\", \"i\", \"u\", \"f\", \"c\")\n    candidate_features = [col for col in train.columns if col != \"yield\"]\n    features = [col for col in candidate_features if train[col].dtype.kind in numeric_kinds]\n    target = \"yield\"\n\n    # ---------- train with simple time-based validation for early stopping ----------\n    train_sorted = train.sort_values([\"year\", \"month\"]).reset_index(drop=True)\n    X = train_sorted[features]\n    y = train_sorted[target]\n\n    split_idx = int(len(train_sorted) * 0.8)\n    X_train, X_valid = X.iloc[:split_idx], X.iloc[split_idx:]\n    y_train, y_valid = y.iloc[:split_idx], y.iloc[split_idx:]\n\n    params = dict(\n        n_estimators=3000,\n        learning_rate=0.03,\n        num_leaves=31,\n        subsample=0.8,\n        subsample_freq=1,\n        colsample_bytree=0.8,\n        reg_alpha=0.1,\n        reg_lambda=0.1,\n        random_state=42,\n        n_jobs=-1,\n    )\n\n    model = lgb.LGBMRegressor(**params)\n    model.fit(\n        X_train,\n        y_train,\n        eval_set=[(X_valid, y_valid)],\n        eval_metric=\"rmse\",\n        early_stopping_rounds=100,\n        verbose=False,\n    )\n\n    best_iter = getattr(model, \"best_iteration_\", None) or params[\"n_estimators\"]\n\n    final_model = lgb.LGBMRegressor(**{**params, \"n_estimators\": best_iter})\n    final_model.fit(train[features], train[target])\n\n    # ---------- predict ----------\n    test_pred = final_model.predict(test[features])\n\n    # ---------- output ----------\n    test_out = test.copy()\n    test_out[\"yield\"] = test_pred\n    test_out = test_out[[\"year\", \"month\", \"state\", \"yield\"]]\n    out_path = OUTPUT_DIR / \"submission.csv\"\n    test_out.to_csv(out_path, index=False)\n    print(f\"\u2705 \u6a21\u578b\u8bad\u7ec3\u5b8c\u6210\uff0c\u9884\u6d4b\u7ed3\u679c\u5df2\u4fdd\u5b58\u81f3: {out_path}\")\n    return out_path\n\n# EVOLVE-BLOCK-END\n\ndef main() -> Path:\n    out_path = train_and_predict()\n    print(f\"Model trained; predictions saved to {out_path}\")\n    return out_path\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\nKey features: Alternative approach to combined_score, Alternative approach to error\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0000, Type: Exploratory)\n```python\n\"\"\"\nBaseline model for bean_test exp2.\n\nReads ./input/train.csv and ./input/test.csv, performs simple preprocessing\n(state encoding + months_since_crop_start), trains a LightGBM regressor, and\nwrites predictions to ./output/submission.csv with columns [year, month, state, yield].\n\nThe EVOLVE-BLOCK marks the scope that OpenEvolve is allowed to tune.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\n# Paths\n# PROJECT_ROOT = Path(__file__).resolve().parent\nPROJECT_ROOT = Path(r\"D:\\\u6e05\u534e\u5de5\u7a0b\u535a\u58eb\\C3I\\AutoMLAgent\\openevolve\\bean_test\\exp1\")\nINPUT_DIR = PROJECT_ROOT / \"input\"\nOUTPUT_DIR = PROJECT_ROOT / \"output\"\nOUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n\nTRAIN_PATH = INPUT_DIR / \"train.csv\"\nTEST_PATH = INPUT_DIR / \"test.csv\"\n\n# EVOLVE-BLOCK-START\nfrom typing import Dict, Tuple\nimport lightgbm as lgb\nimport pandas as pd\n\ndef encode_state(df: pd.DataFrame, mapping: Dict[str, int] | None = None) -> Tuple[pd.DataFrame, Dict[str, int]]:\n    \"\"\"Encode state column to integer IDs.\"\"\"\n    df = df.copy()\n    if mapping is None:\n        states = sorted(df[\"state\"].unique())\n        mapping = {s: i for i, s in enumerate(states)}\n    df[\"state_enc\"] = df[\"state\"].map(mapping).fillna(-1).astype(int)\n    return df, mapping\n\n\ndef months_since_crop_start(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Map month to a simple crop-phase index.\"\"\"\n    df = df.copy()\n\n    def transform(m: int) -> int:\n        return m - 10 if m >= 10 else m + 2\n\n    df[\"months_since_crop_start\"] = df[\"month\"].apply(transform)\n    return df\n\n\ndef train_and_predict() -> Path:\n\n    # ---------- read ----------\n    train = pd.read_csv(TRAIN_PATH)\n    test = pd.read_csv(TEST_PATH)\n\n    # ---------- encode & transform ----------\n    train, state2idx = encode_state(train)\n    test, _ = encode_state(test, mapping=state2idx)\n    train = months_since_crop_start(train)\n    test = months_since_crop_start(test)\n\n    # ---------- feature selection ----------\n    numeric_kinds = (\"b\", \"i\", \"u\", \"f\", \"c\")\n    candidate_features = [col for col in train.columns if col != \"yield\"]\n    features = [col for col in candidate_features if train[col].dtype.kind in numeric_kinds]\n    target = \"yield\"\n\n    # ---------- train with simple time-based validation for early stopping ----------\n    train_sorted = train.sort_values([\"year\", \"month\"]).reset_index(drop=True)\n    X = train_sorted[features]\n    y = train_sorted[target]\n\n    split_idx = int(len(train_sorted) * 0.8)\n    X_train, X_valid = X.iloc[:split_idx], X.iloc[split_idx:]\n    y_train, y_valid = y.iloc[:split_idx], y.iloc[split_idx:]\n\n    params = dict(\n        n_estimators=3000,\n        learning_rate=0.03,\n        num_leaves=31,\n        subsample=0.8,\n        subsample_freq=1,\n        colsample_bytree=0.8,\n        reg_alpha=0.1,\n        reg_lambda=0.1,\n        random_state=42,\n        n_jobs=-1,\n    )\n\n    model = lgb.LGBMRegressor(**params)\n    model.fit(\n        X_train,\n        y_train,\n        eval_set=[(X_valid, y_valid)],\n        eval_metric=\"rmse\",\n        early_stopping_rounds=100,\n        verbose=False,\n    )\n\n    best_iter = getattr(model, \"best_iteration_\", None) or params[\"n_estimators\"]\n\n    final_model = lgb.LGBMRegressor(**{**params, \"n_estimators\": best_iter})\n    final_model.fit(train[features], train[target])\n\n    # ---------- predict ----------\n    test_pred = final_model.predict(test[features])\n\n    # ---------- output ----------\n    test_out = test.copy()\n    test_out[\"yield\"] = test_pred\n    test_out = test_out[[\"year\", \"month\", \"state\", \"yield\"]]\n    out_path = OUTPUT_DIR / \"submission.csv\"\n    test_out.to_csv(out_path, index=False)\n    print(f\"\u2705 \u6a21\u578b\u8bad\u7ec3\u5b8c\u6210\uff0c\u9884\u6d4b\u7ed3\u679c\u5df2\u4fdd\u5b58\u81f3: {out_path}\")\n    return out_path\n\n# EVOLVE-BLOCK-END\n\ndef main() -> Path:\n    out_path = train_and_predict()\n    print(f\"Model trained; predictions saved to {out_path}\")\n    return out_path\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\nUnique approach: Modification: Change 1: Replace 15 lines with 39 lines, Alternative combined_score approach, Comprehensive implementation\n\n### Inspiration 2 (Score: 0.7867, Type: Alternative)\n```python\n\"\"\"\nBaseline model for bean_test exp2.\n\nReads ./input/train.csv and ./input/test.csv, performs simple preprocessing\n(state encoding + months_since_crop_start), trains a LightGBM regressor, and\nwrites predictions to ./output/submission.csv with columns [year, month, state, yield].\n\nThe EVOLVE-BLOCK marks the scope that OpenEvolve is allowed to tune.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\n# Paths\n# PROJECT_ROOT = Path(__file__).resolve().parent\nPROJECT_ROOT = Path(r\"D:\\\u6e05\u534e\u5de5\u7a0b\u535a\u58eb\\C3I\\AutoMLAgent\\openevolve\\bean_test\\exp1\")\nINPUT_DIR = PROJECT_ROOT / \"input\"\nOUTPUT_DIR = PROJECT_ROOT / \"output\"\nOUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n\nTRAIN_PATH = INPUT_DIR / \"train.csv\"\nTEST_PATH = INPUT_DIR / \"test.csv\"\n\n# EVOLVE-BLOCK-START\nfrom typing import Dict, Tuple\nimport lightgbm as lgb\nimport pandas as pd\n\ndef encode_state(df: pd.DataFrame, mapping: Dict[str, int] | None = None) -> Tuple[pd.DataFrame, Dict[str, int]]:\n    \"\"\"Encode state column to integer IDs.\"\"\"\n    df = df.copy()\n    if mapping is None:\n        states = sorted(df[\"state\"].unique())\n        mapping = {s: i for i, s in enumerate(states)}\n    df[\"state_enc\"] = df[\"state\"].map(mapping).fillna(-1).astype(int)\n    return df, mapping\n\n\ndef months_since_crop_start(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Map month to a simple crop-phase index.\"\"\"\n    df = df.copy()\n\n    def transform(m: int) -> int:\n        return m - 10 if m >= 10 else m + 2\n\n    df[\"months_since_crop_start\"] = df[\"month\"].apply(transform)\n    return df\n\n\ndef train_and_predict() -> Path:\n\n    # ---------- read ----------\n    train = pd.read_csv(TRAIN_PATH)\n    test = pd.read_csv(TEST_PATH)\n\n    # ---------- encode & transform ----------\n    train, state2idx = encode_state(train)\n    test, _ = encode_state(test, mapping=state2idx)\n    train = months_since_crop_start(train)\n    test = months_since_crop_start(test)\n\n    # ---------- feature selection ----------\n    numeric_kinds = (\"b\", \"i\", \"u\", \"f\", \"c\")\n    candidate_features = [col for col in train.columns if col != \"yield\"]\n    features = [col for col in candidate_features if train[col].dtype.kind in numeric_kinds]\n    target = \"yield\"\n\n    # ---------- train ----------\n    \n    model = lgb.LGBMRegressor(\n        n_estimators=1000,\n        learning_rate=0.05,\n        num_leaves=63,\n        subsample=0.8,\n        colsample_bytree=0.8,\n        random_state=42\n    )\n    \n    model.fit(train[features], train[target])\n\n    # ---------- predict ----------\n    test_pred = model.predict(test[features])\n\n    # ---------- output ----------\n    test_out = test.copy()\n    test_out[\"yield\"] = test_pred\n    test_out = test_out[[\"year\", \"month\", \"state\", \"yield\"]]\n    out_path = OUTPUT_DIR / \"submission.csv\"\n    test_out.to_csv(out_path, index=False)\n    print(f\"\u2705 \u6a21\u578b\u8bad\u7ec3\u5b8c\u6210\uff0c\u9884\u6d4b\u7ed3\u679c\u5df2\u4fdd\u5b58\u81f3: {out_path}\")\n    return out_path\n\n# EVOLVE-BLOCK-END\n\ndef main() -> Path:\n    out_path = train_and_predict()\n    print(f\"Model trained; predictions saved to {out_path}\")\n    return out_path\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\nUnique approach: Alternative mape approach, Comprehensive implementation\n\n### Inspiration 3 (Score: 0.6046, Type: Alternative)\n```python\n\"\"\"\nBaseline model for bean_test exp2.\n\nReads ./input/train.csv and ./input/test.csv, performs simple preprocessing\n(state encoding + months_since_crop_start), trains a LightGBM regressor, and\nwrites predictions to ./output/submission.csv with columns [year, month, state, yield].\n\nThe EVOLVE-BLOCK marks the scope that OpenEvolve is allowed to tune.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\n# Paths\n# PROJECT_ROOT = Path(__file__).resolve().parent\nPROJECT_ROOT = Path(r\"D:\\\u6e05\u534e\u5de5\u7a0b\u535a\u58eb\\C3I\\AutoMLAgent\\openevolve\\bean_test\\exp1\")\nINPUT_DIR = PROJECT_ROOT / \"input\"\nOUTPUT_DIR = PROJECT_ROOT / \"output\"\nOUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n\nTRAIN_PATH = INPUT_DIR / \"train.csv\"\nTEST_PATH = INPUT_DIR / \"test.csv\"\n\n# EVOLVE-BLOCK-START\nfrom typing import Dict, Tuple\nimport numpy as np\nimport lightgbm as lgb\nimport pandas as pd\n\n\ndef encode_state(\n    df: pd.DataFrame, mapping: Dict[str, int] | None = None\n) -> Tuple[pd.DataFrame, Dict[str, int]]:\n    \"\"\"Encode state column to integer IDs.\"\"\"\n    df = df.copy()\n    if mapping is None:\n        states = sorted(df[\"state\"].unique())\n        mapping = {s: i for i, s in enumerate(states)}\n    df[\"state_enc\"] = df[\"state\"].map(mapping).fillna(-1).astype(int)\n    return df, mapping\n\n\ndef months_since_crop_start(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Map month to a simple crop-phase index.\"\"\"\n    df = df.copy()\n\n    def transform(m: int) -> int:\n        return m - 10 if m >= 10 else m + 2\n\n    df[\"months_since_crop_start\"] = df[\"month\"].apply(transform)\n    return df\n\n\ndef add_calendar_features(df: pd.DataFrame, min_year: int) -> pd.DataFrame:\n    \"\"\"Add simple cyclical/calendar features.\"\"\"\n    df = df.copy()\n    # month as angle on the circle\n    angle = 2.0 * np.pi * (df[\"month\"] - 1) / 12.0\n    df[\"month_sin\"] = np.sin(angle)\n    df[\"month_cos\"] = np.cos(angle)\n    # year normalized so that scale is reasonable\n    df[\"year_norm\"] = df[\"year\"] - min_year\n    return df\n\n\ndef train_and_predict() -> Path:\n    # ---------- read ----------\n    train = pd.read_csv(TRAIN_PATH)\n    test = pd.read_csv(TEST_PATH)\n\n    # ---------- shared stats for transforms ----------\n    min_year = pd.concat([train[\"year\"], test[\"year\"]]).min()\n\n    # ---------- encode & transform ----------\n    train, state2idx = encode_state(train)\n    test, _ = encode_state(test, mapping=state2idx)\n\n    train = months_since_crop_start(train)\n    test = months_since_crop_start(test)\n\n    train = add_calendar_features(train, min_year)\n    test = add_calendar_features(test, min_year)\n\n    # ---------- feature selection ----------\n    numeric_kinds = (\"b\", \"i\", \"u\", \"f\", \"c\")\n    exclude_cols = {\"yield\", \"state\"}\n    features = [\n        col\n        for col in train.columns\n        if col not in exclude_cols and train[col].dtype.kind in numeric_kinds\n    ]\n    target = \"yield\"\n\n    # ---------- train ----------\n    model = lgb.LGBMRegressor(\n        n_estimators=1200,\n        learning_rate=0.03,\n        num_leaves=31,\n        max_depth=-1,\n        subsample=0.9,\n        colsample_bytree=0.9,\n        min_child_samples=20,\n        reg_lambda=0.1,\n        random_state=42,\n        n_jobs=-1,\n    )\n\n    model.fit(train[features], train[target], categorical_feature=[\"state_enc\"])\n\n    # ---------- predict ----------\n    test_pred = model.predict(test[features])\n\n    # ---------- output ----------\n    test_out = test.copy()\n    test_out[\"yield\"] = test_pred\n    test_out = test_out[[\"year\", \"month\", \"state\", \"yield\"]]\n    out_path = OUTPUT_DIR / \"submission.csv\"\n    test_out.to_csv(out_path, index=False)\n    print(f\"Model training finished. Predictions saved to: {out_path}\")\n    return out_path\n\n# EVOLVE-BLOCK-END\n\ndef main() -> Path:\n    out_path = train_and_predict()\n    print(f\"Model trained; predictions saved to {out_path}\")\n    return out_path\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\nUnique approach: Modification: Change 1: Replace 67 lines with 96 lines, Alternative mape approach, Excellent rmse (3.761)\n\n# Current Program\n```python\n\"\"\"\nBaseline model for bean_test exp2.\n\nReads ./input/train.csv and ./input/test.csv, performs simple preprocessing\n(state encoding + months_since_crop_start), trains a LightGBM regressor, and\nwrites predictions to ./output/submission.csv with columns [year, month, state, yield].\n\nThe EVOLVE-BLOCK marks the scope that OpenEvolve is allowed to tune.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\n# Paths\n# PROJECT_ROOT = Path(__file__).resolve().parent\nPROJECT_ROOT = Path(r\"D:\\\u6e05\u534e\u5de5\u7a0b\u535a\u58eb\\C3I\\AutoMLAgent\\openevolve\\bean_test\\exp1\")\nINPUT_DIR = PROJECT_ROOT / \"input\"\nOUTPUT_DIR = PROJECT_ROOT / \"output\"\nOUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n\nTRAIN_PATH = INPUT_DIR / \"train.csv\"\nTEST_PATH = INPUT_DIR / \"test.csv\"\n\n# EVOLVE-BLOCK-START\nfrom typing import Dict, Tuple\nimport lightgbm as lgb\nimport pandas as pd\n\ndef encode_state(df: pd.DataFrame, mapping: Dict[str, int] | None = None) -> Tuple[pd.DataFrame, Dict[str, int]]:\n    \"\"\"Encode state column to integer IDs.\"\"\"\n    df = df.copy()\n    if mapping is None:\n        states = sorted(df[\"state\"].unique())\n        mapping = {s: i for i, s in enumerate(states)}\n    df[\"state_enc\"] = df[\"state\"].map(mapping).fillna(-1).astype(int)\n    return df, mapping\n\n\ndef months_since_crop_start(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Map month to a simple crop-phase index.\"\"\"\n    df = df.copy()\n\n    def transform(m: int) -> int:\n        return m - 10 if m >= 10 else m + 2\n\n    df[\"months_since_crop_start\"] = df[\"month\"].apply(transform)\n    return df\n\n\ndef train_and_predict() -> Path:\n\n    # ---------- read ----------\n    train = pd.read_csv(TRAIN_PATH)\n    test = pd.read_csv(TEST_PATH)\n\n    # ---------- encode & transform ----------\n    train, state2idx = encode_state(train)\n    test, _ = encode_state(test, mapping=state2idx)\n    train = months_since_crop_start(train)\n    test = months_since_crop_start(test)\n\n    # ---------- feature selection ----------\n    numeric_kinds = (\"b\", \"i\", \"u\", \"f\", \"c\")\n    candidate_features = [col for col in train.columns if col != \"yield\"]\n    features = [col for col in candidate_features if train[col].dtype.kind in numeric_kinds]\n    target = \"yield\"\n\n    # ---------- train ----------\n    model = lgb.LGBMRegressor(\n        n_estimators=1000,\n        learning_rate=0.05,\n        num_leaves=63,\n        subsample=0.8,\n        colsample_bytree=0.8,\n        random_state=42,\n    )\n    model.fit(train[features], train[target])\n\n    # ---------- predict ----------\n    test_pred = model.predict(test[features])\n\n    # ---------- output ----------\n    test_out = test.copy()\n    test_out[\"yield\"] = test_pred\n    test_out = test_out[[\"year\", \"month\", \"state\", \"yield\"]]\n    out_path = OUTPUT_DIR / \"submission.csv\"\n    test_out.to_csv(out_path, index=False)\n    print(f\"\u2705 \u6a21\u578b\u8bad\u7ec3\u5b8c\u6210\uff0c\u9884\u6d4b\u7ed3\u679c\u5df2\u4fdd\u5b58\u81f3: {out_path}\")\n    return out_path\n\n# EVOLVE-BLOCK-END\n\ndef main() -> Path:\n    out_path = train_and_predict()\n    print(f\"Model trained; predictions saved to {out_path}\")\n    return out_path\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["<<<<<<< SEARCH\nfrom typing import Dict, Tuple\nimport lightgbm as lgb\nimport pandas as pd\n=======\nfrom typing import Dict, Tuple\nimport numpy as np\nimport lightgbm as lgb\nimport pandas as pd\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n    # ---------- predict ----------\n    test_pred = model.predict(test[features])\n=======\n    # ---------- predict ----------\n    test_pred = model.predict(test[features])\n    # Clip predictions to non-negative values (yields cannot be negative)\n    test_pred = np.clip(test_pred, a_min=0.0, a_max=None)\n>>>>>>> REPLACE"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}